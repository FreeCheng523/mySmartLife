# 项目中Hilt使用方式总结

## 1. 项目配置

### 1.1 版本配置

```toml
# gradle/libs.versions.toml
hiltAndroidGradlePlugin = "2.55"
hiltAndroid = "2.55"
```

### 1.2 依赖配置

```kotlin
// build.gradle.kts
plugins {
    id("dagger.hilt.android.plugin")
    id("kotlin-kapt")
}

dependencies {
    implementation(libs.hilt.android)
    kapt(libs.hilt.compiler)
    implementation(libs.androidx.hilt.navigation.compose)
}
```

## 2. 应用入口配置

### 2.1 Application类配置

```kotlin
// LingDongTieApp.kt
@HiltAndroidApp  // 注释掉了，但应该启用
class LingDongTieApp : Application() {
    @Inject
    lateinit var deviceRepository: DeviceRepository
}
```

## 3. 依赖注入模块设计

### 3.1 应用级模块 (AppModule)

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    @Provides
    @Singleton
    fun provideContext(@ApplicationContext context: Context): Context

    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): AppDatabase

    @Provides
    @Singleton
    fun provideDeviceDao(database: AppDatabase): DeviceDao
}

@Module
@InstallIn(SingletonComponent::class)
abstract class BindsModule {
    @Binds
    @Singleton
    abstract fun bindBleManager(bleManagerImpl: BleManagerImpl): BleManager

    @Binds
    @Singleton
    abstract fun bindDeviceRepository(deviceRepositoryImpl: DeviceRepositoryImpl): DeviceRepository
}
```

### 3.2 功能执行器模块 (FunctionExecutorModule)

```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class FunctionExecutorModule {
    @Binds
    @Singleton
    abstract fun bindFunctionExecutor(impl: FunctionExecutorImpl): FunctionExecutor

    companion object {
        @Provides
        @Singleton
        fun provideAppFunctionExecutor(@ApplicationContext context: Context, deviceRepository: DeviceRepository): AppFunctionExecutor

        @Provides
        @Singleton
        fun provideMediaFunctionExecutor(@ApplicationContext context: Context): MediaFunctionExecutor
    }
}
```

### 3.3 平台特定模块 (TinnoveCarModule)

```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class TinnoveCarModule {
    @Binds
    @Singleton
    abstract fun bindFunctionConfig(impl: TinnoveFunctionConfigCheckImpl): IFunctionConfigCheck

    @Binds
    @Singleton
    abstract fun bindDisplayMKStatus(impl: TinnoveDisplayMKStatusImpl): IDisplayMKStatus

    @Binds
    @Singleton
    abstract fun bindCarFunctionExecutor(impl: TinnoveCarFunctionExecutorImp): ICarFunctionExecutor

    companion object {
        @Provides
        @Singleton
        fun provideTinnoveCarConfig(@ApplicationContext context: Context): TinnoveCarConfig
    }
}
```

## 4. 组件使用方式

### 4.1 Activity使用

```kotlin
@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    @Inject
    lateinit var deviceRepository: DeviceRepository

    private val homeViewModel: HomeViewModel by viewModels()
}
```

### 4.2 ViewModel使用

```kotlin
@HiltViewModel
class HomeViewModel @Inject constructor(
    private val deviceRepository: DeviceRepository,
    private val buttonFunctionEvent: ButtonFunctionEvent,
    private val settingsRepository: SettingsRepository,
    @ApplicationContext private val context: Context,
) : ViewModel()
```

### 4.3 Service使用

```kotlin
@AndroidEntryPoint
class BleService : Service() {
    @Inject
    lateinit var deviceRepository: DeviceRepository
}
```

### 4.4 普通类使用

```kotlin
@Singleton
class FunctionExecutorImpl @Inject constructor(
    @ApplicationContext private val context: Context,
    private val appExecutor: AppFunctionExecutor,
    private val mediaExecutor: MediaFunctionExecutor,
    private val carMediaFunctionExecutor: CarMediaFunctionExecutor,
    private val carFunctionExecutorImp: CarFunctionExecutorImp,
) : FunctionExecutor
```

## 5. 项目中的Hilt使用特点

### 5.1 模块化设计

- **分层模块**：按功能分层组织依赖注入模块
- **接口绑定**：使用`@Binds`进行接口与实现的绑定
- **平台适配**：通过不同平台模块实现依赖倒置

### 5.2 作用域管理

- **单例模式**：大部分依赖使用`@Singleton`作用域
- **应用级作用域**：使用`SingletonComponent`作为安装目标
- **Context注入**：使用`@ApplicationContext`注入应用上下文

### 5.3 依赖关系

- **数据库层**：Room数据库和DAO的依赖注入
- **业务层**：Repository和Service的依赖注入
- **UI层**：ViewModel和Activity的依赖注入
- **平台层**：车机平台特定实现的依赖注入

## 6. 最佳实践总结

### 6.1 模块组织

1. **按功能分层**：AppModule、FunctionExecutorModule、平台特定模块
2. **接口绑定**：使用`@Binds`进行接口与实现的解耦
3. **配置分离**：将配置类单独提供

### 6.2 作用域选择

1. **单例模式**：对于无状态的服务和Repository使用`@Singleton`
2. **应用级作用域**：大部分依赖安装在`SingletonComponent`中
3. **Context注入**：使用`@ApplicationContext`避免内存泄漏

### 6.3 依赖注入原则

1. **依赖倒置**：通过接口抽象实现平台无关性
2. **单一职责**：每个模块负责特定功能的依赖提供
3. **编译时安全**：利用Hilt的编译时检查确保依赖关系正确

### 6.4 平台适配策略

1. **动态依赖选择**：通过gradle配置动态选择平台实现
2. **接口统一**：所有平台实现相同的接口
3. **模块隔离**：平台特定代码独立成模块

## 7. 注意事项

1. **Application类**：需要启用`@HiltAndroidApp`注解
2. **编译配置**：确保正确配置kapt插件
3. **版本兼容**：使用稳定的Hilt版本(2.55)
4. **模块依赖**：注意模块间的依赖关系避免循环依赖

## 8. 项目架构优势

### 8.1 容器控制特征

项目采用了**容器控制**的依赖注入方式，具有以下特征：

- **显式绑定**：接口与实现的关系需要明确声明
- **模块化配置**：按功能模块组织依赖注入配置
- **编译时检查**：依赖关系在编译时确定

### 8.2 依赖倒置实现

通过Hilt实现了良好的依赖倒置：

- **接口抽象**：业务层依赖接口而非具体实现
- **平台解耦**：通过不同平台模块实现平台无关性
- **动态选择**：运行时根据配置选择具体实现

### 8.3 可维护性

- **模块化**：各功能模块独立，便于维护和测试
- **类型安全**：编译时检查确保依赖关系正确
- **扩展性**：新增平台实现只需添加对应模块

## 9. Hilt注解详解

### 9.1 核心注解

#### @HiltAndroidApp

**含义**：标记Application类，启用Hilt依赖注入
**用法**：

```kotlin
@HiltAndroidApp
class LingDongTieApp : Application() {
    // Hilt会自动生成ApplicationComponent
}
```

**作用**：

- 启用Hilt框架
- 生成ApplicationComponent
- 为整个应用提供依赖注入容器

#### @AndroidEntryPoint

**含义**：标记Android组件，使其能够使用依赖注入
**用法**：

```kotlin
@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    @Inject
    lateinit var deviceRepository: DeviceRepository
}

@AndroidEntryPoint
class BleService : Service() {
    @Inject
    lateinit var deviceRepository: DeviceRepository
}
```

**支持的组件**：

- Activity
- Fragment
- Service
- BroadcastReceiver
- ContentProvider
- View

#### @HiltViewModel

**含义**：标记ViewModel，使其能够使用依赖注入
**用法**：

```kotlin
@HiltViewModel
class HomeViewModel @Inject constructor(
    private val deviceRepository: DeviceRepository,
    @ApplicationContext private val context: Context,
) : ViewModel()
```

**特点**：

- 自动处理ViewModel的生命周期
- 支持SavedStateHandle注入
- 与Compose和Fragment无缝集成

### 9.2 依赖注入注解

#### @Inject

**含义**：标记构造函数、字段或方法，表示需要依赖注入
**用法**：

```kotlin
// 构造函数注入（推荐）
@Singleton
class FunctionExecutorImpl @Inject constructor(
    @ApplicationContext private val context: Context,
    private val appExecutor: AppFunctionExecutor,
) : FunctionExecutor

// 字段注入
@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    @Inject
    lateinit var deviceRepository: DeviceRepository
}
```

**规则**：

- 构造函数注入是首选方式
- 字段注入用于Android组件
- 方法注入较少使用

#### @Singleton

**含义**：标记单例作用域，整个应用生命周期内只有一个实例
**用法**：

```kotlin
@Singleton
class DeviceRepositoryImpl @Inject constructor(
    private val deviceDao: DeviceDao
) : DeviceRepository

@Provides
@Singleton
fun provideDatabase(@ApplicationContext context: Context): AppDatabase
```

**特点**：

- 线程安全
- 内存中只存在一个实例
- 适用于无状态的服务

### 9.3 模块注解

#### @Module

**含义**：标记类为Hilt模块，用于提供依赖
**用法**：

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    @Provides
    fun provideContext(@ApplicationContext context: Context): Context
}

@Module
@InstallIn(SingletonComponent::class)
abstract class BindsModule {
    @Binds
    abstract fun bindBleManager(impl: BleManagerImpl): BleManager
}
```

**类型**：

- Object Module：使用`@Provides`提供实例
- Abstract Module：使用`@Binds`绑定接口

#### @InstallIn

**含义**：指定模块安装在哪个组件中
**用法**：

```kotlin
@Module
@InstallIn(SingletonComponent::class)  // 应用级单例
abstract class AppModule

@Module
@InstallIn(ActivityComponent::class)   // Activity级别
abstract class ActivityModule

@Module
@InstallIn(ViewModelComponent::class)  // ViewModel级别
abstract class ViewModelModule
```

**组件类型**：

- `SingletonComponent`：应用级单例
- `ActivityComponent`：Activity级别
- `ViewModelComponent`：ViewModel级别
- `ServiceComponent`：Service级别
- `FragmentComponent`：Fragment级别

### 9.4 提供依赖注解

#### @Provides

**含义**：标记方法，用于提供依赖实例
**用法**：

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): AppDatabase {
        return AppDatabase.getDatabase(context)
    }

    @Provides
    @Singleton
    fun provideDeviceDao(database: AppDatabase): DeviceDao {
        return database.deviceDao()
    }
}
```

**特点**：

- 用于提供第三方库实例
- 用于复杂对象的创建
- 可以包含创建逻辑

#### @Binds

**含义**：标记抽象方法，用于绑定接口到实现
**用法**：

```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class BindsModule {
    @Binds
    @Singleton
    abstract fun bindBleManager(impl: BleManagerImpl): BleManager

    @Binds
    @Singleton
    abstract fun bindDeviceRepository(impl: DeviceRepositoryImpl): DeviceRepository
}
```

**特点**：

- 只能用于抽象方法
- 用于接口与实现的绑定
- 编译时生成实现

### 9.5 限定符注解

#### @ApplicationContext

**含义**：限定注入Application Context
**用法**：

```kotlin
@Provides
@Singleton
fun provideDatabase(@ApplicationContext context: Context): AppDatabase {
    return AppDatabase.getDatabase(context)
}

@HiltViewModel
class HomeViewModel @Inject constructor(
    @ApplicationContext private val context: Context,
) : ViewModel()
```

**作用**：

- 避免内存泄漏
- 提供应用级别的Context
- 与Activity Context区分

#### @ActivityContext

**含义**：限定注入Activity Context
**用法**：

```kotlin
@Provides
fun provideActivityContext(@ActivityContext context: Context): Context {
    return context
}
```

**注意**：

- 可能导致内存泄漏
- 谨慎使用

### 9.6 作用域注解

#### @Singleton

**含义**：单例作用域，应用生命周期内唯一
**用法**：

```kotlin
@Singleton
class DeviceRepositoryImpl @Inject constructor() : DeviceRepository

@Provides
@Singleton
fun provideDatabase(): AppDatabase
```

#### @ActivityScoped

**含义**：Activity作用域，Activity生命周期内唯一
**用法**：

```kotlin
@ActivityScoped
class ActivityScopedClass @Inject constructor()
```

#### @ViewModelScoped

**含义**：ViewModel作用域，ViewModel生命周期内唯一
**用法**：

```kotlin
@ViewModelScoped
class ViewModelScopedClass @Inject constructor()
```

### 9.7 注解使用规则

#### 9.7.1 构造函数注入规则

```kotlin
// ✅ 正确：最多一个构造函数标记@Inject
class ServiceImpl @Inject constructor(
    private val dependency: Dependency
)

// ❌ 错误：多个构造函数不能都标记@Inject
class ServiceImpl @Inject constructor() {
    @Inject constructor(dep: Dependency) // 编译错误
}
```

#### 9.7.2 字段注入规则

```kotlin
@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    @Inject
    lateinit var repository: Repository  // ✅ 正确

    @Inject
    val repository: Repository  // ❌ 错误：不能是val
}
```

#### 9.7.3 模块组织规则

```kotlin
// ✅ 正确：按功能组织模块
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    @Provides
    @Singleton
    fun provideDatabase(): AppDatabase
}

@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    @Binds
    abstract fun bindRepository(impl: RepositoryImpl): Repository
}
```

### 9.8 常见注解组合

#### 9.8.1 单例服务

```kotlin
@Singleton
class BleManagerImpl @Inject constructor(
    @ApplicationContext private val context: Context
) : BleManager
```

#### 9.8.2 接口绑定

```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class ServiceModule {
    @Binds
    @Singleton
    abstract fun bindService(impl: ServiceImpl): Service
}
```

#### 9.8.3 复杂对象提供

```kotlin
@Module
@InstallIn(SingletonComponent::class)
object ConfigModule {
    @Provides
    @Singleton
    fun provideCarConfig(@ApplicationContext context: Context): CarConfig {
        return CarConfig(context)
    }
}
```

## 10. 总结

通过深入分析项目代码，发现项目采用了**容器控制**的依赖注入方式，使用Hilt框架实现了良好的模块化架构。项目中的Hilt使用体现了以下核心特点：

1. **分层模块化设计** - 按功能分层组织依赖注入模块
2. **接口绑定解耦** - 通过`@Binds`实现接口与具体实现的解耦
3. **平台适配策略** - 通过不同平台模块实现依赖倒置原则
4. **编译时安全** - 利用Hilt的编译时检查确保依赖关系正确

这种设计模式使得项目具有良好的可维护性和扩展性，特别是在多平台车机适配方面展现了优秀的架构设计。
